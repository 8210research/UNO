<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Composition Generator</title>
  <style>
    :root { --bg:#111; --btn-bg:#1e90ff; --btn-color:#fff; }
    html,body { height:100%; margin:0; background:var(--bg); color:#fff; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; display:flex; align-items:center; justify-content:center; }
    #container { position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
    #generateBtn {
      position:relative;
      z-index:5;
      padding:20px 40px;
      font-size:20px;
      border-radius:10px;
      border:none;
      background:var(--btn-bg);
      color:var(--btn-color);
      cursor:pointer;
      transition:opacity 2s ease, transform 0.2s;
      user-select:none;
    }
    #generateBtn:disabled { opacity:0.6; cursor:default; }
    #gifOverlay {
      position:absolute;
      z-index:4;
      pointer-events:none;
      user-select:none;
      opacity:0;
      transition:opacity 1s linear;
      max-width:60vmin;
      max-height:60vmin;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #gifOverlay img { display:block; width:100%; height:auto; object-fit:contain; -webkit-user-drag:none; }
    /* center the button exactly */
    .center { display:flex; align-items:center; justify-content:center; }
    /* helper for fade-in/out of button (2s) */
    .fade-out { opacity:0; pointer-events:none; }
    .fade-in { opacity:1; pointer-events:auto; }
  </style>
</head>
<body>
  <div id="container">
    <button id="generateBtn">generate</button>

    <div id="gifOverlay" aria-hidden="true">
      <!-- replace gif.gif with your gif file in project root or in /assets -->
      <img id="gifImage" src="img/progress.gif" alt="" draggable="false" />
    </div>
  </div>

  <script>
  // Configuration
  const MAX_TOTAL_MS = 60_000;      // 1 minute total
  const VOICE_RUN_STOP_MS = 50_000; // voices stop scheduling new items after 50s
  const BUTTON_LOCK_MS = 70_000;    // button locked after press for 70s
  const BUTTON_FADE_MS = 2000;      // button fade durations in ms
  const GIF_FADE_MS = 1000;         // gif fade durations in ms
  const AUDIO_FOLDER = '/audio/';   // audio folder path (files listed in /audio/list.json)
  const MANIFEST_URL = AUDIO_FOLDER + 'list.json';

  // Random helpers
  const rand = (min, max) => Math.random() * (max - min) + min;
  const randInt = (min, max) => Math.floor(rand(min, max + 1));
  const chance = p => Math.random() < p;

  // DOM
  const btn = document.getElementById('generateBtn');
  const gifOverlay = document.getElementById('gifOverlay');

  // WebAudio setup
  let audioCtx = null;
  let masterGain = null;
  let audioBuffers = []; // {name, buffer}
  let manifest = [];

  // State
  let running = false;
  let startTime = 0;
  let scheduledSources = []; // for stopping everything
  let voices = [];
  let allowButton = true;
  let globalFadeInScheduled = false;
  let globalFadeOutScheduled = false;

  // Load manifest and buffers on page load
  window.addEventListener('load', async () => {
    try {
      const resp = await fetch(MANIFEST_URL, {cache: "no-store"});
      if (!resp.ok) throw new Error('Manifest missing');
      manifest = await resp.json();
      // lazy create AudioContext on first user gesture to avoid autoplay policies
    } catch (e) {
      console.warn('Could not load manifest at', MANIFEST_URL, e);
      manifest = [];
    }
  });

  // Utility: ensure audio context and master nodes
  function ensureAudioContext() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 1;
      masterGain.connect(audioCtx.destination);
    }
  }

  // Fetch and decode a single audio file (cached)
  const bufferCache = new Map();
  async function loadBuffer(filename) {
    if (bufferCache.has(filename)) return bufferCache.get(filename);
    const url = AUDIO_FOLDER + filename;
    const resp = await fetch(url);
    const arr = await resp.arrayBuffer();
    const buf = await audioCtx.decodeAudioData(arr.slice(0));
    bufferCache.set(filename, buf);
    return buf;
  }

  // Play a buffer segment with controls (supports reverse by using a reversed copy)
  // options: {playbackRate, volume, maxPlayMs, reverse}
  function playBufferSegment(buffer, when, options = {}) {
    const {playbackRate = 1, volume = 1, maxPlayMs = 10000, reverse = false} = options;

    // create a source from an (maybe reversed) buffer
    const source = audioCtx.createBufferSource();
    let usedBuffer = buffer;
    if (reverse) {
      // make reversed copy
      const channels = [];
      for (let c = 0; c < buffer.numberOfChannels; c++) {
        const chData = buffer.getChannelData(c);
        const rev = new Float32Array(chData.length);
        for (let i = 0, j = chData.length - 1; i < chData.length; i++, j--) rev[i] = chData[j];
        channels.push(rev);
      }
      const revBuf = audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
      for (let c = 0; c < buffer.numberOfChannels; c++) revBuf.getChannelData(c).set(channels[c]);
      usedBuffer = revBuf;
    }
    source.buffer = usedBuffer;
    source.playbackRate.value = playbackRate;

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = volume;

    source.connect(gainNode);
    gainNode.connect(masterGain);

    // compute durations
    const bufferDurationMs = (usedBuffer.duration * 1000) / Math.abs(playbackRate);
    const playMs = Math.min(maxPlayMs, bufferDurationMs);
    const playSeconds = playMs / 1000;

    // schedule start and stop
    source.start(when);
    source.stop(when + playSeconds);

    // track scheduled nodes for later stopping/canceling
    scheduledSources.push({source, gainNode});

    // cleanup after finished
    const cleanupTime = when + playSeconds + 0.1;
    if (audioCtx) {
      // small timeout scheduling using setTimeout relative to audioCtx.currentTime
      const nowSec = audioCtx.currentTime;
      const delay = Math.max(0, (cleanupTime - nowSec) * 1000);
      setTimeout(() => {
        try {
          source.disconnect();
          gainNode.disconnect();
        } catch (e) {}
        // remove from scheduledSources
        scheduledSources = scheduledSources.filter(s => s.source !== source);
      }, delay);
    }

    return {source, gainNode, playMs};
  }

  // Single voice runner
  function createVoice(id) {
    let active = true;
    let voiceState = {id};
    async function run() {
      while (active) {
        // if past voice run stop time, break
        const elapsed = audioCtx.currentTime - startTime;
        if (elapsed * 1000 >= VOICE_RUN_STOP_MS) break;

        // pick random file
        if (!manifest.length) {
          // nothing to play: wait a bit then continue
          await sleep(rand(100, 500));
          continue;
        }
        const file = manifest[randInt(0, manifest.length - 1)];
        const buf = await loadBuffer(file);

        // random playback rate 0.5-2
        const playbackRate = rand(0.5, 2);

        // random play length 10ms - 10s
        const maxPlayMs = rand(10, 10_000);

        // volume: 30% chance 0.1, otherwise random 0.6-1
        const volume = chance(0.3) ? 0.1 : rand(0.6, 1);

        // 50% reverse
        const reverse = chance(0.5);

        // schedule start at now (slightly in future to avoid glitches)
        const when = audioCtx.currentTime + 0.02;
        playBufferSegment(buf, when, {playbackRate, volume, maxPlayMs, reverse});

        // wait for that play to finish or be cut short by global stop: wait actual_ms + small margin
        const bufferDurationMs = (buf.duration * 1000) / Math.abs(playbackRate);
        const actualPlayMs = Math.min(maxPlayMs, bufferDurationMs);
        await sleep(actualPlayMs + 30);

        // after file stops, random silence 1ms-2000ms
        const silenceMs = rand(1, 2000);
        await sleep(silenceMs);
      }
    }
    return {
      start: () => { active = true; run(); },
      stop: () => { active = false; }
    };
  }

  // Sleep helper
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

  // Stop everything immediately and clear scheduled nodes
  function stopAll() {
    try {
      scheduledSources.forEach(({source}) => {
        try { source.stop(); } catch (e) {}
      });
    } catch (e) {}
    scheduledSources = [];
    // stop voices
    voices.forEach(v => v.stop && v.stop());
    voices = [];
  }

  // Fade helpers using masterGain
  function scheduleGlobalFadeIn(durationSec, atTimeSec = audioCtx.currentTime) {
    masterGain.gain.cancelScheduledValues(atTimeSec);
    masterGain.gain.setValueAtTime(0.0001, atTimeSec);
    masterGain.gain.exponentialRampToValueAtTime(1.0, atTimeSec + durationSec);
  }
  function scheduleGlobalFadeOut(durationSec, atTimeSec = audioCtx.currentTime) {
    masterGain.gain.cancelScheduledValues(atTimeSec);
    masterGain.gain.setValueAtTime(masterGain.gain.value || 1.0, atTimeSec);
    // avoid zero in exponential ramp; use small value
    masterGain.gain.exponentialRampToValueAtTime(0.0001, atTimeSec + durationSec);
  }

  // Main generate action
  btn.addEventListener('click', async () => {
    if (!allowButton) return;
    allowButton = false;
    btn.disabled = true;

    // ensure AudioContext resumed/created
    ensureAudioContext();
    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch (e) {}
    }

    // start timestamp
    startTime = audioCtx.currentTime;

    running = true;
    scheduledSources = [];

    // Fade away button over 2s
    btn.style.transition = `opacity ${BUTTON_FADE_MS}ms ease`;
    btn.classList.add('fade-out');
    // after fade-out we hide pointer events
    setTimeout(() => { btn.style.pointerEvents = 'none'; }, BUTTON_FADE_MS);

    // Make GIF fade in immediately (1s)
    gifOverlay.style.transition = `opacity ${GIF_FADE_MS}ms linear`;
    gifOverlay.style.opacity = '1';

    // Optionally schedule global fade-in (60% chance) from 1s to 8s random
    if (chance(0.6)) {
      const dur = rand(1, 8);
      scheduleGlobalFadeIn(dur, audioCtx.currentTime);
      globalFadeInScheduled = true;
    } else {
      // ensure masterGain is 1
      masterGain.gain.setValueAtTime(1.0, audioCtx.currentTime);
    }

    // Optionally schedule global fade-out (30% chance)
    if (chance(0.3)) {
      // fade out for random 3-6s before 60s mark
      const fadeDur = rand(3, 6);
      const fadeEndTime = startTime + (MAX_TOTAL_MS / 1000); // end at 60s
      const fadeStartTime = fadeEndTime - fadeDur;
      // only schedule if fadeStartTime still in future
      if (fadeStartTime > audioCtx.currentTime) {
        scheduleGlobalFadeOut(fadeDur, fadeStartTime);
        globalFadeOutScheduled = true;
      } else {
        // if too late, schedule immediate short fade
        scheduleGlobalFadeOut(Math.min(fadeDur, 3), audioCtx.currentTime + 0.1);
        globalFadeOutScheduled = true;
      }
    }

    // Start three voices
    voices = [createVoice(0), createVoice(1), createVoice(2)];
    voices.forEach(v => v.start());

    // Schedule GIF fade-out at 58s (GIF visible from press until 58s then fades out for 1s)
    setTimeout(() => {
      gifOverlay.style.opacity = '0';
    }, 58_000);

    // Ensure no audio plays after exactly 60s: schedule hard stop
    const stopAt = MAX_TOTAL_MS;
    setTimeout(() => {
      // stop all scheduled sources and voices
      stopAll();
      // reset master gain to 1 and cancel ramps
      if (masterGain) {
        try {
          masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
          masterGain.gain.setValueAtTime(1.0, audioCtx.currentTime + 0.01);
        } catch (e) {}
      }
      running = false;
    }, stopAt);

    // Re-enable button after 70s and fade in at 60s with 2s fade
    // Fade button back in at 60s (1 minute)
    setTimeout(() => {
      btn.style.pointerEvents = 'auto';
      btn.classList.remove('fade-out');
      btn.classList.add('fade-in');
      btn.style.transition = `opacity ${BUTTON_FADE_MS}ms ease`;
      btn.disabled = false;
    }, 60_000);

    // Full lockout duration 70s: allowButton becomes true at 70s
    setTimeout(() => {
      allowButton = true;
      // ensure visible
      btn.classList.remove('fade-out');
      btn.classList.add('fade-in');
    }, BUTTON_LOCK_MS);

  });

  // Prevent any pointer events on gif image (non-interactive)
  gifOverlay.addEventListener('mousedown', e => e.preventDefault());
  gifOverlay.addEventListener('touchstart', e => e.preventDefault());
  gifOverlay.style.pointerEvents = 'none';

  // safeguard: stop all on page hide/unload
  window.addEventListener('visibilitychange', () => {
    if (document.hidden && running) {
      // optionally stop early to avoid audio playing in background
      stopAll();
      running = false;
    }
  });

  window.addEventListener('beforeunload', () => stopAll());

  // If manifest is empty, show small hint in console
  console.log('Random composer loaded. Ensure /audio/list.json exists and lists files inside /audio/ folder.');
  </script>
</body>
</html>

